# 一.事务  

- 目的是为了简化调用数据的操作, 对于使用者简化为提交和回滚两个状态, 不用考虑出现的错误, 比如网络等问题

## 事务的特性（ACID）  

1. 原子性 atom // [ˈætəm]
事务是一个不可分割的工作单位  
2. 一致性  consistency
事务必须使数据库从一个状态转换为另一个一致性状态  
3. 隔离性  isolation
多个用户并发访问数据库时，数据库为每个用户开启一个事务  
4. 持久性  durability
事务提交后的修改永久生效, 即使发生崩溃 -> 通过重做日志  

关系: 原子性和隔离性其实是保证了一致性  

# 二.并发一致性问题

1. 丢失修改  
A 修改一个数据, 随后 B 修改同一数据, 导致 A 数据被覆盖  
2. 脏读
A 修改一个数据, B 读取该数据, 但是 A 撤销了这个修改事务, 此时为脏读  
3. 不可重复读  
A 先读取一个数据, 但事务仍然在, 此时 B 修改了数据, A 再去重复读一次, 数据会不相同  
4. 幻影读  
针对一批数据整体, A 先读取某个范围数据, 之后 B 插入新数据, 此时 A 再次读取, 数据不一致 

# 三. 封锁

## 封锁粒度

行级锁 以及 表级锁

## 封锁类型

1. 读写锁

# 四.隔离级别

1. read uncommitted (未提交读)  
事务中的修改, 即使未提交, 其他事务也可见  
2. read commit (提交读)  
其他事务只允许读已被提交的数据  
3. repeatable read (可重复读)  
在一个事务中，对同一个项，多次读取的结果一样 -> 避免脏读、不可重复读（mysql默认）  
4. serializable (序列化)  
保证可串行化读取 -> 可避免脏读、不可重复读、幻读  
用锁实现  

# 五.日志类型

1. 重做日志 -> 数据页的物理修改, 整体页数据  
保持事务的持久性，方式发生故障时,可以根据日志重做，从而达到持久性特性  
2. 回滚日志 -> 记录数据的逻辑修改, 具体的操作  
保存了事务发生之前的数据的一个版本，可以用于回滚  
3. 二进制日志：  
用于主从复制中，从库利用主库上二进制日志进行重播，实现主从同步  
以上三个与事务操作有关  
错误日志、慢查询日志、一般查询日志、中继日志  

# 六.关系数据库设计理论

## 索引  

选取的核心：index太大只能存在硬盘中 所以选取层数少的平衡树能降低IO

### B树与B+树  

优势：减少读取次数，减少磁盘I/O  
B树：
结点上既为数据又可以充当索引  
B+树：
1. 非叶子结点上不存储数据，只存储索引，只有在叶子结点上存储数据，这样可以存储更多的索引，使树更矮
2. 提供顺序读取能力，提高区间scan能力

### LSM
优点：
1. 读写分离，先写入内存，再写入硬盘，降低index写入IO  
2. 分两颗树，内存中为红黑树（数据小 没必要牺牲cpu去维持高度），磁盘中为B+树  
3. 基于硬盘的数据结构 写入磁盘减少磁盘臂移动  
缺点：  
1. LSM树中进行读取时，可能需要检查多个文件
2. 写放大可能导致更多的数据需要被合并，进而影响读取性能。

### 索引设置
1. 复合索引：等值过滤_排序键_多值过滤 比如event_type.event_ts
2. 



## 三范式  

- 第一范式
  - 每个属性都不能再分割  
- 第二范式  
  - 消除了非主属性对键码的部分函数依赖  
  - 例： 学号 姓名 课程名
  - （学号、姓名） -> 课程名 // 学号和姓名共同构成码  
  - （姓名） -> 课程名  // 姓名也可以单独成为码  
- 第三范式  
  - 消除了非主属性对码的传递函数依赖  
  - 例：  
  - (学号) -> 姓名  
  - 姓名 -> 课程名  // 非主属性姓名也可以推出课程名
